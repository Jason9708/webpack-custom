# webpack 如何解析代码模块路径

模块化开发的前端工作规范已经深入人心，在webpack支持的模块化中，我们可以使用`import xxx from 'xxx.js`

又例如我们用`VUE`进行开发的时候，必须使用`import vue from 'Vue'`，`webpack`在构建的时候，会解析依赖，然后再去加载依赖的模块文件

那么`webpack`是如何将 `xxx.js` 或者 `Vue` 解析成模块文件路径呢❓

### 模块解析规则

- 解析相对路径
    - 查找相对当前模块的路径下是否有对应文件或者是文件夹
    - 是文件则直接加载
    - 是文件夹则继续查找文件夹下的`package.json`
    - 存在`package.json`文件则按照文件中`main`字段的文件名来查找文件
    - 若无`package.json`或者没有`main`字段，则默认查找`index.js`
- 解析模块名
    - 查找当前文件目录下，父级目录及以上目录下的`node_modules`文件夹，看是否有对应名称的模块
- 解析绝对路径
    - 直接查找对应路径的文件


在`webpack`中，和模块路径解析有关的配置都在`resolve`字段里
```
module.exports = {
    resolve: {
        //...
    }
}
```


### resolve 常用配置
- resolve.alias 设置别名

先假设我们有个`utils`模块用来作为我们的工具文件，并且在整个项目中经常需要引入，那么如果我们每次引入都用路径去引入，就会显得很麻烦，所以我们可以通过配置别名，达到`import 'utils'`的效果
```
alias: {
    utils: path.resolve(__dirname,'src/utils') // 通过path.resolve和__dirname来获取绝对路径
}
```

这样配置别名采用的是**模糊匹配**，即只要模块中携带了`utils`就会被替换掉
```
import 'utils/form.js' // 相当于引入了 'src/utils/form.js'
```

若想采用精确匹配，需要在别名后加上`$`
```
alias: {
    utils$: path.resolve(__dirname,'src/utils') // 通过path.resolve和__dirname来获取绝对路径
}
```